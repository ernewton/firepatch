
; Performs blinear interpolation to fix bad pixels from a given mask.
; If no mask is provided, a default archived mask is used, and
; the masked pixels are returned in the mask keyword

function fire_badpixfix, rawimg, msk=msk

  if (not keyword_set(MSK) or n_elements(msk) LT 2) then begin
     mask = transpose(reverse(xmrdfits(strtrim(getenv("FIRE_DIR"),2)+"/Calib/fire_badpix_new.fits.gz")))
     msk=mask ; For return value to set invvar accordingly
     print, "WARNING: new mas!" 
  endif
  mask = msk ; ERN hack because broken
  yimg = (intarr(2048)+1) # indgen(2048)
  ximg = indgen(2048) # (intarr(2048)+1) 
  
  badpix = where(mask EQ 0, nmsk)
  gdpix = where(mask EQ 1, ngd)
  cleaned = rawimg * mask

  if (nmsk GT 0) then begin

     if (0) then begin ; SLOW METHOD
        for imsk=0, nmsk-1 do begin
           cleaned[ximg[badpix], yimg[badpix]] = $
              (cleaned[ximg[badpix]-1,yimg[badpix]]+ $
               cleaned[ximg[badpix]+1,yimg[badpix]]+ $
               cleaned[ximg[badpix],yimg[badpix]+1]+ $
               cleaned[ximg[badpix],yimg[badpix]-1]) / 4.0
        endfor
     endif else begin

        interp_img  = (shift(cleaned,  1,  0) + $
                      shift(cleaned, -1,  0) + $
                      shift(cleaned,  0, -1) + $
                      shift(cleaned,  0,  1)) / 4.0

        cleaned[badpix] = interp_img[badpix]
     
     endelse

  endif

  return, cleaned

end


; make a filled in bad pix mask, which I will use.
function badpixfill

  mask = xmrdfits(strtrim(getenv("FIRE_DIR"),2)+"/Calib/fire_badpix.fits.gz")
  yimg = (intarr(2048)+1) # indgen(2048)
  ximg = indgen(2048) # (intarr(2048)+1) 
  msk=mask ; For return value to set invvar accordingly
  badpix = where(mask EQ 0, nmsk)


  npix = size(msk, /N_ELEMENTS)
  for i=1, 2046 do begin
  for j=1, 2046 do begin
  
    flag = 0
    if mask[i+1,j] EQ 0 then flag = flag+1 
    if mask[i-1,j] EQ 0 then flag = flag+1 
    if mask[i,j+1] EQ 0 then flag = flag+1 
    if mask[i,j-1] EQ 0 then flag = flag+1 
    
    if flag GE 3 then begin ; if surrounded by bad pix, mark as badpix
      msk[i,j] = 0
;       print, i, j, msk[i,j]
;       print, mask[i-4:i+4,j-4:j+4]
;       if mask[i,j] EQ 1 THEN stop
    endif

   endfor
   endfor

   mwrfits, msk, strtrim(getenv("FIRE_DIR"),2)+"/Calib/fire_badpix_filled.fits.gz", /create
return, badpixnew
end

function badpixnew

  dark = xmrdfits(strtrim(getenv("FIRE_DIR"),2)+"/Calib/fowler16dark.fits")
  s = stddev(dark[WHERE(abs(dark) LT 8.8)]) ; about 5 sigma clip
  
  mask = dark * 0.
  mask[WHERE(ABS(dark) LT 5.*s)] = 1
  
  mwrfits, mask, strtrim(getenv("FIRE_DIR"),2)+"/Calib/fire_badpix_new.fits.gz", /create
 
  return, mask
  
end